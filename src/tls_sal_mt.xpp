// 
// Cryptographic Security Abstraction Layer API - this version uses MIRACL core functions + TIIcrypto
//

#include "tls_sal.h"

// Pull in MIRACL core code

#include "core.h"
#include "ecdh_NIST256.h"  
#include "ecdh_NIST384.h"
#include "ecdh_C25519.h"
#include "rsa_RSA2048.h"
#include "rsa_RSA4096.h"

// Use TIIcrypto 

#define TII_CURVE_25519

extern "C" 
{
    #include "aes.h"
    #include "aes_gcm.h"
    #include "chacha20.h"
    #include "chacha20_poly1305_aead.h"
    #include "tii_prng.h"
    #include "sha2.h"
    #include "eckeys.h"
    #include "eddsa.h"
}

// define hash algorithms
#define TLS_SHA256_T 1
#define TLS_SHA384_T 2
#define TLS_SHA512_T 3

using namespace core;

csprng RNG;    // Global miracl core Crypto Strong RNG - could be a hardware source

bool SAL_initLib()
{ // Initialise library
    uint8_t raw[100];
    tii_prng_get_bytes(raw, 100); // get true random seed
    RAND_seed(&RNG, 100, (char *)raw);  
    return true;
}

int SAL_ciphers(int *ciphers)
{
    int n=2;
    ciphers[0]=TLS_AES_128_GCM_SHA256;
    ciphers[1]=TLS_AES_256_GCM_SHA384;
    return n;
}

int SAL_groups(int *groups)
{
    int n=3;
    groups[0]=X25519;
    groups[1]=SECP256R1;
    groups[2]=SECP384R1;
    return n;
}

int SAL_sigs(int *sigAlgs)
{
    int n=4;
    sigAlgs[0]=ECDSA_SECP256R1_SHA256;
    sigAlgs[1]=RSA_PSS_RSAE_SHA256;
    sigAlgs[2]=ECDSA_SECP384R1_SHA384;
    sigAlgs[3]=ED25519;
    return n;
}

int SAL_sigCerts(int *sigAlgsCert)
{
    int n=6;
    sigAlgsCert[0]=ECDSA_SECP256R1_SHA256;
    sigAlgsCert[1]=RSA_PKCS1_SHA256;
    sigAlgsCert[2]=ECDSA_SECP384R1_SHA384;
    sigAlgsCert[3]=RSA_PKCS1_SHA384;
    sigAlgsCert[4]=RSA_PKCS1_SHA512;
    sigAlgsCert[5]=ED25519;

    return n;
}

// return hashtype from cipher_suite
int SAL_hashType(int cipher_suite)
{
    int htype=TLS_SHA256_T;   // SHA256 default;
    if (cipher_suite==TLS_AES_128_GCM_SHA256) htype=TLS_SHA256_T;
    if (cipher_suite==TLS_AES_256_GCM_SHA384) htype=TLS_SHA384_T;
    if (cipher_suite==TLS_CHACHA20_POLY1305_SHA256) htype=TLS_SHA256_T;
    return htype;
}

// return hash length from hash type
int SAL_hashLen(int hash_type)
{
    int hlen=0;
    if (hash_type==TLS_SHA256_T) hlen=32;
    if (hash_type==TLS_SHA384_T) hlen=48;
    if (hash_type==TLS_SHA512_T) hlen=64;
    return hlen;
}

// convert TLS octad to MIRACL core octet
static octet octad_to_octet(octad *x)
{
    octet y;
    if (x!=NULL) {
        y.len=x->len;
        y.max=x->max;
        y.val=x->val;
    } else {
        y.len=y.max=0;
        y.val=NULL;
    }
    return y;
}

// Return a random byte
int SAL_randomByte()
{
    uint8_t b[1];
    tii_prng_get_bytes(b, 1);
    return (int)b[0]&0xff;
}

// Fill an octad with random values
void SAL_randomOctad(int len,octad *R)
{
    tii_prng_get_bytes((uint8_t *)R->val, len);
    R->len=len;
}

// create expanded HKDF label LB from label and context
static void hkdfLabel(octad *LB,int length,octad *Label,octad *CTX)
{
    OCT_append_int(LB,length,2);    // 2
    OCT_append_byte(LB,(char)(6+Label->len),1);  // 1
    OCT_append_string(LB,(char *)"tls13 ");   // 6
    OCT_append_octad(LB,Label);  // Label->len
    if (CTX!=NULL)
    {
        OCT_append_byte(LB, (char)(CTX->len), 1); // 1
        OCT_append_octad(LB,CTX);   // CTX->len
    } else {
        OCT_append_byte(LB,0,1);   // 1
    }
}

// HKDF extension for TLS1.3
void SAL_hkdfExpandLabel(int htype,octad *OKM,int olen,octad *PRK,octad *Label,octad *CTX)
{
    int hlen=SAL_hashLen(htype);
    char hl[TLS_MAX_HASH+24];
    octad HL={0,sizeof(hl),hl};

    octet MC_OKM=octad_to_octet(OKM); 
    octet MC_PRK=octad_to_octet(PRK);

    hkdfLabel(&HL,olen,Label,CTX);
    octet MC_HL=octad_to_octet(&HL);
    HKDF_Expand(MC_SHA2,hlen,&MC_OKM,olen,&MC_PRK,&MC_HL);
    OKM->len=MC_OKM.len;
    PRK->len=MC_PRK.len;
}

// HKDF - Extract secret from raw input
void SAL_hkdfExtract(int htype,octad *PRK,octad *SALT,octad *IKM)
{
    int hlen=SAL_hashLen(htype);
    octet MC_PRK=octad_to_octet(PRK);   // Make it MIRACL core compatible
    octet MC_SALT=octad_to_octet(SALT);
    octet MC_IKM=octad_to_octet(IKM);

    HKDF_Extract(MC_SHA2,hlen,&MC_PRK,&MC_SALT,&MC_IKM);

    IKM->len=MC_IKM.len;              // restore length
    SALT->len=MC_SALT.len;
    PRK->len=MC_PRK.len;
}

// HMAC
void SAL_hmac(int htype,octad *T,octad *K,octad *M)
{
    int hlen=SAL_hashLen(htype);
    if (htype==TLS_SHA256_T) {
        sha256hmac_ctx_t hmacctx;
        sha256hmac_reset(&hmacctx,(uint8_t *)K->val,hlen);
        sha256hmac_update(&hmacctx,(uint8_t *)M->val,(const uint64_t)M->len);
        sha256hmac_final(&hmacctx,(uint8_t *)T->val,hlen);
        T->len=hlen;
    }
    if (htype==TLS_SHA384_T) {

        sha384hmac_ctx_t hmacctx;
        sha384hmac_reset(&hmacctx,(uint8_t *)K->val,hlen);
        sha384hmac_update(&hmacctx,(uint8_t *)M->val,(const uint64_t)M->len);
        sha384hmac_final(&hmacctx,(uint8_t *)T->val,hlen);

        T->len=hlen;
    }
    if (htype==TLS_SHA512_T) {
        sha512hmac_ctx_t hmacctx;
        sha512hmac_reset(&hmacctx,(uint8_t *)K->val,hlen);
        sha512hmac_update(&hmacctx,(uint8_t *)M->val,(const uint64_t)M->len);
        sha512hmac_final(&hmacctx,(uint8_t *)T->val,hlen);
        T->len=hlen;
    }
}

// HASH of NULL
void SAL_hashNull(int htype,octad *H)
{
    int hlen=SAL_hashLen(htype);
    if (htype==TLS_SHA256_T) {
        sha256_ctx_t h;
        sha256_reset(&h);
        sha256_final(&h,(uint8_t *)H->val,hlen);
    }
    if (htype==TLS_SHA384_T) {
        sha384_ctx_t h;
        sha384_reset(&h);
        sha384_final(&h,(uint8_t *)H->val,hlen);
    }
    if (htype==TLS_SHA512_T) {
        sha512_ctx_t h;
        sha512_reset(&h);
        sha512_final(&h,(uint8_t *)H->val,hlen);
    }
    H->len=hlen;
}

// Unified hashing. Hash type type indicate by htype.
void SAL_hashInit(int htype,unihash *h)
{
    if (htype==TLS_SHA256_T) 
        sha256_reset((sha256_ctx_t *)&(h->state));
    if (htype==TLS_SHA384_T)
        sha384_reset((sha384_ctx_t *)&(h->state));
    if (htype==TLS_SHA512_T)
        sha512_reset((sha512_ctx_t *)&(h->state));
    h->htype=htype;
}

// Process a byte
void SAL_hashProcess(unihash *h,int b)
{
    uint8_t c[1];
    c[0]=(uint8_t)b;
    if (h->htype==TLS_SHA256_T)
        sha256_update((sha256_ctx_t *)&(h->state),c,1);
    if (h->htype==TLS_SHA384_T)
        sha384_update((sha384_ctx_t *)&(h->state),c,1);
    if (h->htype==TLS_SHA512_T)
        sha512_update((sha512_ctx_t *)&(h->state),c,1);
}

// output digest, return length
int SAL_hashOutput(unihash *h,char *d)
{
    unihash f=*h;  // make copy of state
    int hlen=SAL_hashLen(h->htype);
    if (h->htype==TLS_SHA256_T)
        sha256_final((sha256_ctx_t *)&(f.state),(uint8_t *)d,hlen);
    if (h->htype==TLS_SHA384_T)
        sha384_final((sha384_ctx_t *)&(f.state),(uint8_t *)d,hlen);
    if (h->htype==TLS_SHA512_T)
        sha512_final((sha512_ctx_t *)&(f.state),(uint8_t *)d,hlen);
    return hlen;
}

void SAL_aeadEncrypt(crypto *send,int hdrlen,char *hdr,int ptlen,char *pt,octad *TAG)
{ // AEAD encryption
    if (send->suite==TLS_CHACHA20_POLY1305_SHA256)
    { 
        uint8_t iv[8];
        uint8_t constant[4];
        for (int i=0;i<4;i++)
            constant[i]=send->IV.val[i];
        for (int i=0;i<8;i++)
            iv[i]=send->IV.val[4+i];
        chacha20_poly1305_aead_encrypt((uint8_t *)send->K.val,iv,constant,(uint8_t *)pt,(uint64_t)ptlen,(uint8_t *)hdr,(uint64_t)hdrlen,(uint8_t *)pt,(uint8_t *)TAG->val);
    } 
    if (send->suite==TLS_AES_128_GCM_SHA256)
    {
        aes128_gcm_encrypt((uint8_t *)send->K.val,(uint8_t *)send->IV.val,12,(uint8_t *)pt,(uint64_t)ptlen,(uint8_t *)hdr,(uint64_t)hdrlen,(uint8_t *)pt,(uint8_t *)TAG->val);
    }
    if (send->suite==TLS_AES_256_GCM_SHA384)
    {
        aes256_gcm_encrypt((uint8_t *)send->K.val,(uint8_t *)send->IV.val,12,(uint8_t *)pt,(uint64_t)ptlen,(uint8_t *)hdr,(uint64_t)hdrlen,(uint8_t *)pt,(uint8_t *)TAG->val);
    }
    TAG->len=16;
}

int SAL_aeadDecrypt(crypto *recv,int hdrlen,char *hdr,int ctlen,char *ct,octad *TAG)
{ // AEAD decryption
    if (recv->suite==TLS_CHACHA20_POLY1305_SHA256)
    {
        uint8_t iv[8];
        uint8_t constant[4];
        for (int i=0;i<4;i++)
            constant[i]=recv->IV.val[i];
        for (int i=0;i<8;i++)
            iv[i]=recv->IV.val[4+i];
        return chacha20_poly1305_aead_decrypt((uint8_t *)recv->K.val,iv,constant,(uint8_t *)ct,(uint64_t)ctlen,(uint8_t *)hdr,(uint64_t)hdrlen,(uint8_t *)ct,(uint8_t *)TAG->val);
    }
    if (recv->suite==TLS_AES_128_GCM_SHA256)
    {
        return aes128_gcm_decrypt((uint8_t *)recv->K.val,(uint8_t *)recv->IV.val,12,(uint8_t *)ct,(uint64_t)ctlen,(uint8_t *)hdr,(uint64_t)hdrlen,(uint8_t *)ct,(uint8_t *)TAG->val);
    }
    if (recv->suite==TLS_AES_256_GCM_SHA384)
    {
        return aes256_gcm_decrypt((uint8_t *)recv->K.val,(uint8_t *)recv->IV.val,12,(uint8_t *)ct,(uint64_t)ctlen,(uint8_t *)hdr,(uint64_t)hdrlen,(uint8_t *)ct,(uint8_t *)TAG->val);
    }
    return -1;
}

// generate a public/private key pair in an approved group for a key exchange
void SAL_generateKeyPair(int group,octad *SK,octad *PK)
{
// Random secret key
    SAL_randomOctad(32,SK);
    if (group==X25519)
    { // RFC7748 the secret key
        SK->val[31]&=248;  
        SK->val[0]&=127;
        SK->val[0]|=64;
    }

/*
    ec_private_key_t private_key;
    ec_public_key_t public_key;
    ec_public_key_init(&public_key);

    ec_private_key_init(&private_key);
    for (int i=0;i<32;i++) private_key.bytes_representation[i]=SK->val[i];
    gfco_set_nbo(&private_key.internal_representation, private_key.bytes_representation,32);

    printf("Private key= ");
    for (int i=0;i<32;i++)
        printf("%02x",private_key.bytes_representation[i]);
    printf("\n");

    ec_public_key_gen(&public_key,&private_key);
    printf("Public key= \n");
    printf("x= ");
    for (int i=0;i<32;i++)
        printf("%02x",public_key.public_x[i]);
    printf("\n");
    printf("y= ");
    for (int i=0;i<32;i++)
        printf("%02x",public_key.public_y[i]);
    printf("\n");
*/


    octet MC_SK=octad_to_octet(SK);
    octet MC_PK=octad_to_octet(PK);
    if (group==X25519)
    { // Note that this program maintains the private key in big-endian format
      // But X25519 assumes private and public keys are all in little-endian form (and are transmitted/received in that form)
        C25519::ECP_KEY_PAIR_GENERATE(NULL, &MC_SK, &MC_PK);
/*    
    printf("Public key= \n");
    printf("x= ");
    for (int i=0;i<32;i++)
        printf("%02x",(unsigned char)(MC_PK.val[i]&0xff));   
    printf("\n");
*/
        OCT_reverse(&MC_PK);  // public key must be transmitted in little-endian form
    }
    if (group==SECP256R1)
    {
        NIST256::ECP_KEY_PAIR_GENERATE(NULL, &MC_SK, &MC_PK);
    }
    if (group==SECP384R1)
    {
        NIST384::ECP_KEY_PAIR_GENERATE(NULL, &MC_SK, &MC_PK);
    }

    SK->len=MC_SK.len;
    PK->len=MC_PK.len;

}

// generate shared secret SS from secret key SK and public key PK
void SAL_generateSharedSecret(int group,octad *SK,octad *PK,octad *SS)
{
    octet MC_SK=octad_to_octet(SK);
    octet MC_PK=octad_to_octet(PK);
    octet MC_SS=octad_to_octet(SS);

    if (group==X25519) {
        OCT_reverse(&MC_PK); // to big endian
        C25519::ECP_SVDP_DH(&MC_SK, &MC_PK, &MC_SS,0);
        OCT_reverse(&MC_PK); // back again
        OCT_reverse(&MC_SS);
    }
    if (group==SECP256R1) {
        NIST256::ECP_SVDP_DH(&MC_SK, &MC_PK, &MC_SS,0);
    }
    if (group==SECP384R1) {
        NIST384::ECP_SVDP_DH(&MC_SK, &MC_PK, &MC_SS,0);
    }
    SK->len=MC_SK.len;
    PK->len=MC_PK.len;
    SS->len=MC_SS.len;
}

// RSA 2048-bit PKCS1.5 signature verification
static bool RSA_2048_PKCS15_VERIFY(int sha,octad *CERT,octad *SIG,octad *PUBKEY)
{
    bool res;
    char p1[RFS_RSA2048];
    octet P1={0,sizeof(p1),p1};
    char p2[RFS_RSA2048];
    octet P2={0,sizeof(p2),p2};

    octet MC_CERT=octad_to_octet(CERT);
    octet MC_SIG=octad_to_octet(SIG);
    octet MC_PUBKEY=octad_to_octet(PUBKEY);

    RSA2048::rsa_public_key PK;
    PK.e = 65537; // assuming this!
    RSA2048::RSA_fromOctet(PK.n, &MC_PUBKEY);
    RSA2048::RSA_ENCRYPT(&PK, &MC_SIG, &P2);
    PKCS15(sha, &MC_CERT, &P1);
    res=OCT_comp(&P1, &P2);
    if (!res)
    { // check alternate PKCS1.5 encoding
        PKCS15b(sha, &MC_CERT, &P1);
        res=OCT_comp(&P1, &P2);
    }
    return res;
}

// RSA 4096-bit PKCS1.5 signature verification
static bool RSA_4096_PKCS15_VERIFY(int sha,octad *CERT,octad *SIG,octad *PUBKEY)
{
    bool res;
    char p1[RFS_RSA4096];
    octet P1={0,sizeof(p1),p1};
    char p2[RFS_RSA4096];
    octet P2={0,sizeof(p2),p2};

    octet MC_CERT=octad_to_octet(CERT);
    octet MC_SIG=octad_to_octet(SIG);
    octet MC_PUBKEY=octad_to_octet(PUBKEY);

    RSA4096::rsa_public_key PK;
    PK.e = 65537; // assuming this!
    RSA4096::RSA_fromOctet(PK.n, &MC_PUBKEY);
    RSA4096::RSA_ENCRYPT(&PK, &MC_SIG, &P2);
    PKCS15(sha, &MC_CERT, &P1);
    res=OCT_comp(&P1, &P2);
    if (!res)
    { // check alternate PKCS1.5 encoding
        PKCS15b(sha, &MC_CERT, &P1);
        res=OCT_comp(&P1, &P2);
    }
    return res;
}

static bool RSA_PKCS15_VERIFY(int sha,octad *CERT,octad *SIG,octad *PUBKEY)
{
    if (PUBKEY->len==RFS_RSA2048)
        return RSA_2048_PKCS15_VERIFY(sha,CERT,SIG,PUBKEY);
    if (PUBKEY->len==RFS_RSA4096)
        return RSA_4096_PKCS15_VERIFY(sha,CERT,SIG,PUBKEY);
    return false;
}

// RSA 2048-bit PSS-RSAE signature verification
static bool RSA_2048_PSS_RSAE_VERIFY(int sha,octad *MESS,octad *SIG,octad *PUBKEY)
{
    char p[RFS_RSA2048];
    octet P={0,sizeof(p),p};

    octet MC_MESS=octad_to_octet(MESS);
    octet MC_SIG=octad_to_octet(SIG);
    octet MC_PUBKEY=octad_to_octet(PUBKEY);

    RSA2048::rsa_public_key PK;
    PK.e = 65537;
    RSA2048::RSA_fromOctet(PK.n, &MC_PUBKEY);
    RSA2048::RSA_ENCRYPT(&PK, &MC_SIG, &P);
    if (PSS_VERIFY(sha,&MC_MESS,&P)) 
        return true;
    return false;
}

// RSA 4096-bit PSS-RSAE signature verification
static bool RSA_4096_PSS_RSAE_VERIFY(int sha,octad *MESS,octad *SIG,octad *PUBKEY)
{
    char p[RFS_RSA4096];
    octet P={0,sizeof(p),p};

    octet MC_MESS=octad_to_octet(MESS);
    octet MC_SIG=octad_to_octet(SIG);
    octet MC_PUBKEY=octad_to_octet(PUBKEY);

    RSA4096::rsa_public_key PK;
    PK.e = 65537;
    RSA4096::RSA_fromOctet(PK.n, &MC_PUBKEY);
    RSA4096::RSA_ENCRYPT(&PK, &MC_SIG, &P);
    if (PSS_VERIFY(sha,&MC_MESS,&P)) 
        return true;
    return false;
}

static bool RSA_PSS_RSAE_VERIFY(int sha,octad *MESS,octad *SIG,octad *PUBKEY)
{
    if (PUBKEY->len==RFS_RSA2048)
        return RSA_2048_PSS_RSAE_VERIFY(sha,MESS,SIG,PUBKEY);
    if (PUBKEY->len==RFS_RSA4096)
        return RSA_4096_PSS_RSAE_VERIFY(sha,MESS,SIG,PUBKEY);
    return false;
}

// Curve SECP256R1 elliptic curve ECDSA verification
static bool SECP256R1_ECDSA_VERIFY(int sha,octad *CERT,octad *SIG,octad *PUBKEY)
{
    int res;

    octet MC_CERT=octad_to_octet(CERT);
    octet MC_SIG=octad_to_octet(SIG);
    octet MC_PUBKEY=octad_to_octet(PUBKEY);

    res=NIST256::ECP_PUBLIC_KEY_VALIDATE(&MC_PUBKEY);
    if (res!=0) return false;

    char r[32];
    octet R={0,sizeof(r),r};
    char s[32];
    octet S={0,sizeof(s),s};
    int siglen=SIG->len/2;
    for (int i=0;i<siglen;i++)
    {
        OCT_jbyte(&R,MC_SIG.val[i],1);
        OCT_jbyte(&S,MC_SIG.val[i+siglen],1);
    }    

    res=NIST256::ECP_VP_DSA(sha, &MC_PUBKEY, &MC_CERT, &R, &S);
    if (res!=0) return false;

    return true;
}

// Curve SECP384R1 elliptic curve ECDSA verification
static bool SECP384R1_ECDSA_VERIFY(int sha,octad *CERT,octad *SIG,octad *PUBKEY)
{
    int res;

    octet MC_CERT=octad_to_octet(CERT);
    octet MC_SIG=octad_to_octet(SIG);
    octet MC_PUBKEY=octad_to_octet(PUBKEY);

    res=NIST384::ECP_PUBLIC_KEY_VALIDATE(&MC_PUBKEY);
    if (res!=0) return false;

    char r[48];
    octet R={0,sizeof(r),r};
    char s[48];
    octet S={0,sizeof(s),s};
    int siglen=SIG->len/2;
    for (int i=0;i<siglen;i++)
    {
        OCT_jbyte(&R,MC_SIG.val[i],1);
        OCT_jbyte(&S,MC_SIG.val[i+siglen],1);
    }    

    res=NIST384::ECP_VP_DSA(sha, &MC_PUBKEY, &MC_CERT, &R, &S);
    if (res!=0) return false;

    return true;
}

static bool Ed25519_VERIFY(octad *CERT,octad *SIG,octad *PUBKEY)
{ 
    eddsa_public_key_t pk;
    eddsa_signature_t sig;

    for (int i=0;i<ED25519_DSA_PUBLIC_KEY_SIZE_IN_BYTES;i++)
        pk[i]=PUBKEY->val[i];
    for (int i=0;i<ED25519_DSA_SIGNATURE_SIZE_IN_BYTES;i++)
        sig[i]=SIG->val[i];

    int result=eddsa_verify(&sig,&pk,(uint8_t *)CERT->val,CERT->len);

    if (result == 0) 
        return true;
    return false;
}

// Use Curve SECP256R1 ECDSA to digitally sign a message using a private key 
static void SECP256R1_ECDSA_SIGN(int sha,octad *KEY,octad *MESS,octad *SIG)
{
    octet MC_MESS=octad_to_octet(MESS);
    octet MC_KEY=octad_to_octet(KEY);
    octet MC_SIG=octad_to_octet(SIG);

    char r[32];
    octet R={0,sizeof(r),r};
    char s[32];
    octet S={0,sizeof(s),s};

    NIST256::ECP_SP_DSA(sha, &RNG, NULL, &MC_KEY, &MC_MESS, &R, &S);

    OCT_copy(&MC_SIG,&R);
    OCT_joctet(&MC_SIG,&S);

    SIG->len=MC_SIG.len;
}

// Use Curve SECP384R1 ECDSA to digitally sign a message using a private key 
static void SECP384R1_ECDSA_SIGN(int sha,octad *KEY,octad *MESS,octad *SIG)
{
    octet MC_MESS=octad_to_octet(MESS);
    octet MC_KEY=octad_to_octet(KEY);
    octet MC_SIG=octad_to_octet(SIG);

    char r[48];
    octet R={0,sizeof(r),r};
    char s[48];
    octet S={0,sizeof(s),s};

    NIST384::ECP_SP_DSA(sha, &RNG, NULL, &MC_KEY, &MC_MESS, &R, &S);

    OCT_copy(&MC_SIG,&R);
    OCT_joctet(&MC_SIG,&S);

    SIG->len=MC_SIG.len;
}

static void Ed25519_SIGN(octad *KEY,octad *MESS,octad *SIG)
{ 
    eddsa_private_key_t sk;
    eddsa_signature_t sig;

    for (int i=0;i<ED25519_DSA_PRIVATE_KEY_SIZE_IN_BYTES;i++)
        sk.private_key[i]=KEY->val[i];
    eddsa_public_key_gen(&(sk.public_key),&sk);   // ??

    eddsa_sign(&sig,&sk,(uint8_t *)MESS->val,MESS->len);

    SIG->len=ED25519_DSA_SIGNATURE_SIZE_IN_BYTES;
    for (int i=0;i<ED25519_DSA_SIGNATURE_SIZE_IN_BYTES;i++)
        SIG->val[i]=sig[i];   
}

// Use RSA-2048 PSS-RSAE to digitally sign a message using a private key
static void RSA_2048_PSS_RSAE_SIGN(int sha,octad *KEY,octad *MESS,octad *SIG)
{
    int len=KEY->len/5;   // length of p and q
    if (len!=128) return;
    char p[128];
    octet P={len,sizeof(p),p};
    char q[128];
    octet Q={len,sizeof(q),q};
    char dp[128];
    octet DP={len,sizeof(dp),dp};
    char dq[128];
    octet DQ={len,sizeof(dq),dq};
    char c[128];
    octet C={len,sizeof(c),c}; 
    for (int i=0;i<len;i++)
    {
        p[i]=KEY->val[i];
        q[i]=KEY->val[i+len];
        dp[i]=KEY->val[i+2*len];
        dq[i]=KEY->val[i+3*len];
        c[i]=KEY->val[i+4*len];
    }
    RSA2048::rsa_private_key SK;
    char enc[256];
    octet ENC={0,sizeof(enc),enc};
    RSA2048::RSA_PRIVATE_KEY_FROM_OPENSSL(&P,&Q,&DP,&DQ,&C,&SK);

    octet MC_MESS=octad_to_octet(MESS);
    octet MC_SIG=octad_to_octet(SIG);

    PSS_ENCODE(sha, &MC_MESS, &RNG, &ENC);
    RSA2048::RSA_DECRYPT(&SK,&ENC,&MC_SIG);
    SIG->len=MC_SIG.len;
}

// Use RSA-4096 PSS-RSAE to digitally sign a message using a private key
static void RSA_4096_PSS_RSAE_SIGN(int sha,octad *KEY,octad *MESS,octad *SIG)
{
    int len=KEY->len/5;   // length of p and q
    if (len!=256) return;
    char p[256];
    octet P={len,sizeof(p),p};
    char q[256];
    octet Q={len,sizeof(q),q};
    char dp[256];
    octet DP={len,sizeof(dp),dp};
    char dq[256];
    octet DQ={len,sizeof(dq),dq};
    char c[256];
    octet C={len,sizeof(c),c}; 
    for (int i=0;i<len;i++)
    {
        p[i]=KEY->val[i];
        q[i]=KEY->val[i+len];
        dp[i]=KEY->val[i+2*len];
        dq[i]=KEY->val[i+3*len];
        c[i]=KEY->val[i+4*len];
    }
    RSA4096::rsa_private_key SK;
    char enc[512];
    octet ENC={0,sizeof(enc),enc};

    octet MC_MESS=octad_to_octet(MESS);
    octet MC_SIG=octad_to_octet(SIG);

    RSA4096::RSA_PRIVATE_KEY_FROM_OPENSSL(&P,&Q,&DP,&DQ,&C,&SK);
    PSS_ENCODE(sha, &MC_MESS, &RNG, &ENC);
    RSA4096::RSA_DECRYPT(&SK,&ENC,&MC_SIG);
    SIG->len=MC_SIG.len;
}

static void RSA_PSS_RSAE_SIGN(int sha,octad *KEY,octad *MESS,octad *SIG)
{
    int len=KEY->len/5;
    if (len==128) RSA_2048_PSS_RSAE_SIGN(sha,KEY,MESS,SIG);
    if (len==256) RSA_4096_PSS_RSAE_SIGN(sha,KEY,MESS,SIG);
}

// RFC8446:     "A TLS-compliant application MUST support digital signatures with
//              rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for
//              CertificateVerify and certificates), and ecdsa_secp256r1_sha256."

// Certificate Signature Verification
bool SAL_certSignatureVerify(int sigAlg,octad *CERT,octad *SIG,octad *PUBKEY)
{
    bool res=false;
    switch (sigAlg) {
        case 0x0403 :
            return SECP256R1_ECDSA_VERIFY(32,CERT,SIG,PUBKEY); 
        case 0x0503 :
            return SECP384R1_ECDSA_VERIFY(48,CERT,SIG,PUBKEY);
        case 0x0807 :
            return Ed25519_VERIFY(CERT,SIG,PUBKEY);
        case 0x0401 :
            return RSA_PKCS15_VERIFY(32,CERT,SIG,PUBKEY); 
        case 0x0501 :
            return RSA_PKCS15_VERIFY(48,CERT,SIG,PUBKEY); 
        case 0x0601 :
            return RSA_PKCS15_VERIFY(64,CERT,SIG,PUBKEY); 
        default:
            return false;
    }
    return false;
}

// Transcript Signature Verification
bool SAL_tlsSignatureVerify(int sigAlg,octad *TRANS,octad *SIG,octad *PUBKEY)
{ // probably need to support more cases
    switch (sigAlg)
    {
    case 0x0804:
        return RSA_PSS_RSAE_VERIFY(32,TRANS,SIG,PUBKEY);
    case 0x0403:  
        return SECP256R1_ECDSA_VERIFY(32,TRANS,SIG,PUBKEY);
    case 0x0503:
        return SECP384R1_ECDSA_VERIFY(48,TRANS,SIG,PUBKEY);
    case 0x0807:
        return Ed25519_VERIFY(TRANS,SIG,PUBKEY);
    default :
        return false;
    }
    return false;
}

// Form Transcript Signature 
void SAL_tlsSignature(int sigAlg,octad *KEY,octad *TRANS,octad *SIG)
{ // probably need to support more cases
    switch (sigAlg)
    {
    case 0x0804:
        RSA_PSS_RSAE_SIGN(32,KEY,TRANS,SIG);
        break;
    case 0x0807:
        Ed25519_SIGN(KEY,TRANS,SIG) ;
        break;
    case 0x0403:
        SECP256R1_ECDSA_SIGN(32,KEY,TRANS,SIG);
        break;
    case 0x0503:
        SECP384R1_ECDSA_SIGN(48,KEY,TRANS,SIG);
        break;
    }
}

.TH "C:/Users/mscot/TLS1.3/cpp/include/tls_octads.h" 3 "Mon Oct 3 2022" "Version 1.2" "TiigerTLS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/mscot/TLS1.3/cpp/include/tls_octads.h \- octad handling routines - octads don't overflow, they truncate  

.SH SYNOPSIS
.br
.PP
\fC#include <stddef\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBoctad\fP"
.br
.RI "Safe representation of an octad\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBOCT_append_int\fP (\fBoctad\fP *O, unsigned int x, int len)"
.br
.RI "Join len bytes of integer x to end of octad O (big endian) "
.ti -1c
.RI "void \fBOCT_append_octad\fP (\fBoctad\fP *O, \fBoctad\fP *P)"
.br
.RI "Join one octad to the end of another\&. "
.ti -1c
.RI "bool \fBOCT_compare\fP (\fBoctad\fP *O, \fBoctad\fP *P)"
.br
.RI "Compare two octads\&. "
.ti -1c
.RI "void \fBOCT_shift_left\fP (\fBoctad\fP *O, int n)"
.br
.RI "Shifts octad left by n bytes\&. "
.ti -1c
.RI "void \fBOCT_kill\fP (\fBoctad\fP *O)"
.br
.RI "Wipe clean an octad\&. "
.ti -1c
.RI "void \fBOCT_from_hex\fP (\fBoctad\fP *O, char *src)"
.br
.RI "Convert a hex number to an octad\&. "
.ti -1c
.RI "void \fBOCT_append_string\fP (\fBoctad\fP *O, char *s)"
.br
.RI "Join from a C string to end of an octad\&. "
.ti -1c
.RI "void \fBOCT_append_byte\fP (\fBoctad\fP *O, int b, int n)"
.br
.RI "Join single byte to end of an octad, repeated n times\&. "
.ti -1c
.RI "void \fBOCT_append_bytes\fP (\fBoctad\fP *O, char *s, int n)"
.br
.RI "Join bytes to end of an octad\&. "
.ti -1c
.RI "void \fBOCT_from_base64\fP (\fBoctad\fP *O, char *b)"
.br
.RI "Create an octad from a base64 number\&. "
.ti -1c
.RI "void \fBOCT_reverse\fP (\fBoctad\fP *O)"
.br
.RI "Reverse bytes in an octad\&. "
.ti -1c
.RI "void \fBOCT_truncate\fP (\fBoctad\fP *O, int n)"
.br
.RI "Reverse bytes in an octad\&. "
.ti -1c
.RI "void \fBOCT_copy\fP (\fBoctad\fP *O, \fBoctad\fP *P)"
.br
.RI "Copy one octad into another\&. "
.ti -1c
.RI "bool \fBOCT_output_hex\fP (\fBoctad\fP *O, int max, char *s)"
.br
.RI "Output octad as hex string\&. "
.ti -1c
.RI "bool \fBOCT_output_string\fP (\fBoctad\fP *O, int max, char *s)"
.br
.RI "Output octad as C ascii string\&. "
.ti -1c
.RI "void \fBOCT_output_base64\fP (\fBoctad\fP *O, int max, char *s)"
.br
.RI "Output octad as base64 string\&. "
.in -1c
.SH "Detailed Description"
.PP 
octad handling routines - octads don't overflow, they truncate 


.PP
\fBAuthor\fP
.RS 4
Mike Scott  
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "void OCT_append_byte (\fBoctad\fP * O, int b, int n)"

.PP
Join single byte to end of an octad, repeated n times\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be written to 
.br
\fIb\fP byte to be joined to end of octad 
.br
\fIn\fP number of times b is to be joined 
.RE
.PP

.SS "void OCT_append_bytes (\fBoctad\fP * O, char * s, int n)"

.PP
Join bytes to end of an octad\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be written to 
.br
\fIs\fP byte array to be joined to end of octad 
.br
\fIn\fP number of bytes to join 
.RE
.PP

.SS "void OCT_append_int (\fBoctad\fP * O, unsigned int x, int len)"

.PP
Join len bytes of integer x to end of octad O (big endian) 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be appended to 
.br
\fIx\fP integer to be appended to O 
.br
\fIlen\fP number of bytes in m 
.RE
.PP

.SS "void OCT_append_octad (\fBoctad\fP * O, \fBoctad\fP * P)"

.PP
Join one octad to the end of another\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be appended to 
.br
\fIP\fP octad to be joined to the end of O 
.RE
.PP

.SS "void OCT_append_string (\fBoctad\fP * O, char * s)"

.PP
Join from a C string to end of an octad\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be written to 
.br
\fIs\fP zero terminated string to be joined to octad 
.RE
.PP

.SS "bool OCT_compare (\fBoctad\fP * O, \fBoctad\fP * P)"

.PP
Compare two octads\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP first octad to be compared 
.br
\fIP\fP second octad to be compared 
.RE
.PP
\fBReturns\fP
.RS 4
true if equal, else false 
.RE
.PP

.SS "void OCT_copy (\fBoctad\fP * O, \fBoctad\fP * P)"

.PP
Copy one octad into another\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be copied to 
.br
\fIP\fP octad to be copied from 
.RE
.PP

.SS "void OCT_from_base64 (\fBoctad\fP * O, char * b)"

.PP
Create an octad from a base64 number\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be populated 
.br
\fIb\fP zero terminated base64 string 
.RE
.PP

.SS "void OCT_from_hex (\fBoctad\fP * O, char * src)"

.PP
Convert a hex number to an octad\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad 
.br
\fIsrc\fP Hex string to be converted 
.RE
.PP

.SS "void OCT_kill (\fBoctad\fP * O)"

.PP
Wipe clean an octad\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be cleared 
.RE
.PP

.SS "void OCT_output_base64 (\fBoctad\fP * O, int max, char * s)"

.PP
Output octad as base64 string\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be output 
.br
\fImax\fP the maximum output length 
.br
\fIs\fP the char array to receive output 
.RE
.PP

.SS "bool OCT_output_hex (\fBoctad\fP * O, int max, char * s)"

.PP
Output octad as hex string\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be output 
.br
\fImax\fP the maximum output length 
.br
\fIs\fP the char array to receive output 
.RE
.PP

.SS "bool OCT_output_string (\fBoctad\fP * O, int max, char * s)"

.PP
Output octad as C ascii string\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be output 
.br
\fImax\fP the maximum output length 
.br
\fIs\fP the char array to receive output 
.RE
.PP

.SS "void OCT_reverse (\fBoctad\fP * O)"

.PP
Reverse bytes in an octad\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be reversed 
.RE
.PP

.SS "void OCT_shift_left (\fBoctad\fP * O, int n)"

.PP
Shifts octad left by n bytes\&. Leftmost bytes disappear 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be shifted 
.br
\fIn\fP number of bytes to shift 
.RE
.PP

.SS "void OCT_truncate (\fBoctad\fP * O, int n)"

.PP
Reverse bytes in an octad\&. 
.PP
\fBParameters\fP
.RS 4
\fIO\fP octad to be truncated 
.br
\fIn\fP the new shorter length 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for TiigerTLS from the source code\&.

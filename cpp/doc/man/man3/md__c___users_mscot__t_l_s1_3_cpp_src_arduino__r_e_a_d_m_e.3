.TH "md__c___users_mscot__t_l_s1_3_cpp_src_arduino__r_e_a_d_m_e" 3 "Mon Oct 3 2022" "Version 1.2" "TiigerTLS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md__c___users_mscot__t_l_s1_3_cpp_src_arduino__r_e_a_d_m_e \- Configure the Arduino Nano RP2040 
.PP
This build is specifically for the Arduino Nano version of the Raspberry Pi Pico (RP2040)\&. Please use version 2\&.x\&.x of the Arduino IDE\&.
.PP
First the board needs to be initialised and locked\&. To do this install the ArduinoECCX08 library and run the ECCX08SelfSignedCert example program\&.
.PP
(This example program appears when an MKR1000 board is suggested, and may not appear for the RP2040\&. However it runs fine on the RP2040)\&.
.PP
This program (a) locks the board, and (b) generates a self-signed X\&.509 certificate, with an associated private key hidden in Slot 0\&. Copy the self-signed certificate and place it into tls_client_cert\&.cpp where indicated\&.
.PP
Note that the ECC608A chip does a lot of the heavy crypto lifting, especially if the secp256r1 curve is used for certificate signature verification\&.
.PP
The key exchange secret is generated in Slot 1\&. Slot 9 is used for the HMAC calculation\&. See the ECC608A documentation for more detail\&.
.SH "Building the client application on the Arduino Nano RP2040 board\&."
.PP
.IP "1." 4
Create working directory directory with name tiitls
.IP "2." 4
Copy in all from the cpp directory of https://github.com/miracl/core
.IP "3." 4
Copy in all from the arduino directory of https://github.com/miracl/core
.IP "4." 4
(If ever asked to overwrite a file, go ahead and overwrite it)
.IP "5." 4
Copy in all of the TLS1\&.3 C++ code from the lib/, include/, sal/ and src/arduino directories (but not from subdirectories)
.IP "6." 4
Edit the file core\&.h to define CORE_ARDUINO (line 31)
.IP "7." 4
Edit the file \fBtls_sockets\&.h\fP to define TLS_ARDUINO (line 13)\&.
.IP "8." 4
Edit \fBtls1_3\&.h\fP\&. Define VERBOSITY as IO_DEBUG for more debug output\&. Decide on CRYPTO_SETTING\&. Stack only, or Stack plus heap\&.
.IP "9." 4
Edit the file client\&.cpp to set your wifi SSID and password (near line 150)
.IP "10." 4
Run py config\&.py, and select options 2, 8, 41 and 43\&. This creates the default SAL (in this case using miracl + ECC608A hardware)\&.
.IP "11." 4
Drop the working directory into where the Arduino IDE expects it\&.
.IP "12." 4
(In the IDE select File->Preferences and find the Sketchbook location - its the libraries directory off that\&.)
.IP "13." 4
Open the Arduino app, and look in File->Examples->tiitls, and look for the example 'client'
.IP "14." 4
Upload to the board and run it\&. Open Tools->Serial Monitor to see the output\&.
.IP "15." 4
Enter URL (e\&.g\&. www\&.bbc\&.co\&.uk) when prompted, and press return\&. A full TLS1\&.3 handshake followed by a resumption is attempted\&.
.IP "16." 4
Click on Clear Output and Send to repeat for a different URL (or click Send again to see SAL capabilities)\&.
.PP
.PP
or before executing step 10, search for $*$*$*$* in config\&.py (around line 1020) and make changes as indicated\&. If using miracl alone, without hardware support, option 3 must be selected as well\&. If using assembly language code for X25519, copy x25519\&.S from https://github.com/pornin/x25519-cm0/blob/main/src/x25519-cm0.S into working directory and remove option 2\&. This creates the SAL (in this case using miracl + ECC608A hardware + Pornin's x25519)\&. If experimenting with post-quantum primitives, also select options 45 and 46, for Kyber and Dilithium support\&.
.PP
The example TLS1\&.3 client code first connects to the wireless network, and after that it should connect to standard websites, as long as they support TLS1\&.3\&. The example program first makes a full TLS handshake, and exits after receiving some HTML from the server\&. Then after a few seconds, if it has received a resumption ticket, it attempts a resumption handshake\&.
.PP
The client can also be run in conjunction with our Rust server\&. Make sure that the CRYPTO_SETTING parameter is the same for both client and server\&. In our experimental set-up, the rust server runs from Windows, looking for connections on port 4433\&. Run ipconfig to get the IP address of the server on the local network, which might look something like 192\&.168\&.1\&.186\&. Then run the client from the Arduino IDE, and when prompted enter for example 192\&.168\&.1\&.186:4433\&. The client should now connect to the server\&. 

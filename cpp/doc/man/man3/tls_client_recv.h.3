.TH "C:/Users/mscot/TLS1.3/cpp/include/tls_client_recv.h" 3 "Mon Oct 3 2022" "Version 1.2" "TiigerTLS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/mscot/TLS1.3/cpp/include/tls_client_recv.h \- Process Input received from the Server\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'tls_sal\&.h'\fP
.br
\fC#include 'tls1_3\&.h'\fP
.br
\fC#include 'tls_sockets\&.h'\fP
.br
\fC#include 'tls_keys_calc\&.h'\fP
.br
\fC#include 'tls_client_send\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBret\fP \fBparseoctad\fP (\fBoctad\fP *E, int len, \fBoctad\fP *M, int &ptr)"
.br
.RI "Parse out an octad from a pointer into an octad\&. "
.ti -1c
.RI "\fBret\fP \fBparsebytes\fP (char *e, int len, \fBoctad\fP *M, int &ptr)"
.br
.RI "Parse out byte array from a pointer into an octad\&. "
.ti -1c
.RI "\fBret\fP \fBparseInt\fP (\fBoctad\fP *M, int len, int &ptr)"
.br
.RI "Parse out an unsigned integer from a pointer into an octad\&. "
.ti -1c
.RI "\fBret\fP \fBparseoctadptr\fP (\fBoctad\fP *E, int len, \fBoctad\fP *M, int &ptr)"
.br
.RI "Return a pointer to an octad from a pointer into an octad\&. "
.ti -1c
.RI "int \fBgetServerFragment\fP (\fBTLS_session\fP *session)"
.br
.RI "Read a record from the Server, a fragment of a full protocol message\&. "
.ti -1c
.RI "\fBret\fP \fBparseIntorPull\fP (\fBTLS_session\fP *session, int len)"
.br
.RI "Parse out an unsigned integer from a pointer into an octad, if necessary pulling in a new fragment\&. "
.ti -1c
.RI "\fBret\fP \fBparseoctadorPull\fP (\fBTLS_session\fP *session, \fBoctad\fP *O, int len)"
.br
.RI "Parse out an octad from a pointer into an octad, if necessary pulling in a new fragment\&. "
.ti -1c
.RI "\fBret\fP \fBparsebytesorPull\fP (\fBTLS_session\fP *session, char *o, int len)"
.br
.RI "Parse out a byte array from a pointer into an octad, if necessary pulling in a new fragment\&. "
.ti -1c
.RI "\fBret\fP \fBparseoctadorPullptrX\fP (\fBTLS_session\fP *session, \fBoctad\fP *O, int len)"
.br
.RI "Return a pointer to an octad from a pointer into an octad, if necessary pulling in a new fragment\&. "
.ti -1c
.RI "bool \fBbadResponse\fP (\fBTLS_session\fP *session, \fBret\fP r)"
.br
.RI "Process response from server input\&. "
.ti -1c
.RI "\fBret\fP \fBseeWhatsNext\fP (\fBTLS_session\fP *session)"
.br
.RI "Identify type of incoming message\&. "
.ti -1c
.RI "\fBret\fP \fBgetServerEncryptedExtensions\fP (\fBTLS_session\fP *session, \fBee_status\fP *enc_ext_expt, \fBee_status\fP *enc_ext_resp)"
.br
.RI "Receive and parse Server Encrypted Extensions\&. "
.ti -1c
.RI "\fBret\fP \fBgetServerCertVerify\fP (\fBTLS_session\fP *session, \fBoctad\fP *SCVSIG, int &sigalg)"
.br
.RI "Get Server proof that he owns the Certificate, by receiving and verifying its signature on transcript hash\&. "
.ti -1c
.RI "\fBret\fP \fBgetServerFinished\fP (\fBTLS_session\fP *session, \fBoctad\fP *HFIN)"
.br
.RI "Get final handshake message from Server, a HMAC on the transcript hash\&. "
.ti -1c
.RI "\fBret\fP \fBgetServerHello\fP (\fBTLS_session\fP *session, int &kex, \fBoctad\fP *CK, \fBoctad\fP *PK, int &pskid)"
.br
.RI "Receive and parse initial Server Hello\&. "
.ti -1c
.RI "\fBret\fP \fBgetCheckServerCertificateChain\fP (\fBTLS_session\fP *session, \fBoctad\fP *PUBKEY, \fBoctad\fP *SIG)"
.br
.RI "Receive and check certificate chain\&. "
.ti -1c
.RI "\fBret\fP \fBgetCertificateRequest\fP (\fBTLS_session\fP *session, int &nalgs, int *sigalgs)"
.br
.RI "process a Certificate Request "
.in -1c
.SH "Detailed Description"
.PP 
Process Input received from the Server\&. 


.PP
\fBAuthor\fP
.RS 4
Mike Scott  
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "bool badResponse (\fBTLS_session\fP * session, \fBret\fP r)"

.PP
Process response from server input\&. 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS1\&.3 session structure 
.br
\fIr\fP return value to be processed 
.RE
.PP
\fBReturns\fP
.RS 4
true, if its a bad response requiring an abort 
.RE
.PP

.SS "\fBret\fP getCertificateRequest (\fBTLS_session\fP * session, int & nalgs, int * sigalgs)"

.PP
process a Certificate Request 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS session structure 
.br
\fInalgs\fP the number of acceptable signature algorithms 
.br
\fIsigalgs\fP an array of nalgs signature algorithms 
.RE
.PP
\fBReturns\fP
.RS 4
response structure 
.RE
.PP

.SS "\fBret\fP getCheckServerCertificateChain (\fBTLS_session\fP * session, \fBoctad\fP * PUBKEY, \fBoctad\fP * SIG)"

.PP
Receive and check certificate chain\&. 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS session structure 
.br
\fIPUBKEY\fP the public key extracted from the Server certificate 
.br
\fISIG\fP signature (supplied as workspace) 
.RE
.PP
\fBReturns\fP
.RS 4
response structure 
.RE
.PP

.SS "\fBret\fP getServerCertVerify (\fBTLS_session\fP * session, \fBoctad\fP * SCVSIG, int & sigalg)"

.PP
Get Server proof that he owns the Certificate, by receiving and verifying its signature on transcript hash\&. 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS session structure 
.br
\fISCVSIG\fP the received signature on the transcript hash 
.br
\fIsigalg\fP the type of the received signature 
.RE
.PP
\fBReturns\fP
.RS 4
response structure 
.RE
.PP

.SS "\fBret\fP getServerEncryptedExtensions (\fBTLS_session\fP * session, \fBee_status\fP * enc_ext_expt, \fBee_status\fP * enc_ext_resp)"

.PP
Receive and parse Server Encrypted Extensions\&. 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS session structure 
.br
\fIenc_ext_expt\fP ext structure containing server expectations 
.br
\fIenc_ext_resp\fP ext structure containing server responses 
.RE
.PP
\fBReturns\fP
.RS 4
response structure 
.RE
.PP

.SS "\fBret\fP getServerFinished (\fBTLS_session\fP * session, \fBoctad\fP * HFIN)"

.PP
Get final handshake message from Server, a HMAC on the transcript hash\&. 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS session structure 
.br
\fIHFIN\fP an octad containing HMAC on transcript as calculated by Server 
.RE
.PP
\fBReturns\fP
.RS 4
response structure 
.RE
.PP

.SS "int getServerFragment (\fBTLS_session\fP * session)"

.PP
Read a record from the Server, a fragment of a full protocol message\&. 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS session structure 
.RE
.PP
\fBReturns\fP
.RS 4
a positive indication of the record type, or a negative error return 
.RE
.PP

.SS "\fBret\fP getServerHello (\fBTLS_session\fP * session, int & kex, \fBoctad\fP * CK, \fBoctad\fP * PK, int & pskid)"

.PP
Receive and parse initial Server Hello\&. 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS session structure 
.br
\fIkex\fP key exchange data 
.br
\fICK\fP an output Cookie 
.br
\fIPK\fP the key exchange public value supplied by the Server 
.br
\fIpskid\fP indicates if a pre-shared key was accepted, otherwise -1 
.RE
.PP
\fBReturns\fP
.RS 4
response structure 
.RE
.PP

.SS "\fBret\fP parsebytes (char * e, int len, \fBoctad\fP * M, int & ptr)"

.PP
Parse out byte array from a pointer into an octad\&. 
.PP
\fBParameters\fP
.RS 4
\fIe\fP the output byte array copied out from the octad M 
.br
\fIlen\fP the expected length of e 
.br
\fIM\fP the input octad 
.br
\fIptr\fP a pointer into M, which advances after use 
.RE
.PP
\fBReturns\fP
.RS 4
the actual length of e extracted, and an error flag 
.RE
.PP

.SS "\fBret\fP parsebytesorPull (\fBTLS_session\fP * session, char * o, int len)"

.PP
Parse out a byte array from a pointer into an octad, if necessary pulling in a new fragment\&. 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS session structure 
.br
\fIo\fP the output bytes 
.br
\fIlen\fP the expected length of the output 
.RE
.PP
\fBReturns\fP
.RS 4
the actual length of o extracted, and an error flag 
.RE
.PP

.SS "\fBret\fP parseInt (\fBoctad\fP * M, int len, int & ptr)"

.PP
Parse out an unsigned integer from a pointer into an octad\&. 
.PP
\fBParameters\fP
.RS 4
\fIM\fP the input octad 
.br
\fIlen\fP the number of bytes in integer 
.br
\fIptr\fP a pointer into M, which advances after use 
.RE
.PP
\fBReturns\fP
.RS 4
the integer value, and an error flag 
.RE
.PP

.SS "\fBret\fP parseIntorPull (\fBTLS_session\fP * session, int len)"

.PP
Parse out an unsigned integer from a pointer into an octad, if necessary pulling in a new fragment\&. 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS session structure 
.br
\fIlen\fP the number of bytes in integer 
.RE
.PP
\fBReturns\fP
.RS 4
the unsigned integer, and an error flag 
.RE
.PP

.SS "\fBret\fP parseoctad (\fBoctad\fP * E, int len, \fBoctad\fP * M, int & ptr)"

.PP
Parse out an octad from a pointer into an octad\&. 
.PP
\fBParameters\fP
.RS 4
\fIE\fP the output octad copied out from the octad M 
.br
\fIlen\fP the expected length of the output octad E 
.br
\fIM\fP the input octad 
.br
\fIptr\fP a pointer into M, which advances after use 
.RE
.PP
\fBReturns\fP
.RS 4
the actual length of E extracted, and an error flag 
.RE
.PP

.SS "\fBret\fP parseoctadorPull (\fBTLS_session\fP * session, \fBoctad\fP * O, int len)"

.PP
Parse out an octad from a pointer into an octad, if necessary pulling in a new fragment\&. 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS session structure 
.br
\fIO\fP the output octad 
.br
\fIlen\fP the expected length of the output octad O 
.RE
.PP
\fBReturns\fP
.RS 4
the actual length of O extracted, and an error flag 
.RE
.PP

.SS "\fBret\fP parseoctadorPullptrX (\fBTLS_session\fP * session, \fBoctad\fP * O, int len)"

.PP
Return a pointer to an octad from a pointer into an octad, if necessary pulling in a new fragment\&. 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS session structure 
.br
\fIO\fP a pointer to an octad contained within an octad IO 
.br
\fIlen\fP the expected length of the octad O 
.RE
.PP
\fBReturns\fP
.RS 4
the actual length of O extracted, and an error flag 
.RE
.PP

.SS "\fBret\fP parseoctadptr (\fBoctad\fP * E, int len, \fBoctad\fP * M, int & ptr)"

.PP
Return a pointer to an octad from a pointer into an octad\&. 
.PP
\fBParameters\fP
.RS 4
\fIE\fP a pointer to an octad contained within an octad M 
.br
\fIlen\fP the expected length of the octad E 
.br
\fIM\fP the input octad 
.br
\fIptr\fP a pointer into M, which advances after use 
.RE
.PP
\fBReturns\fP
.RS 4
the actual length of E, and an error flag 
.RE
.PP

.SS "\fBret\fP seeWhatsNext (\fBTLS_session\fP * session)"

.PP
Identify type of incoming message\&. 
.PP
\fBParameters\fP
.RS 4
\fIsession\fP the TLS session structure 
.RE
.PP
\fBReturns\fP
.RS 4
negative error, zero for OK, or positive for message type 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for TiigerTLS from the source code\&.
